// Code generated by Bootstrap.
//
// Please edit this to more accurately match the server implementation.

package registrard

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/apparentlymart/go-cidr/cidr"
	"github.com/google/uuid"
	"github.com/jaredallard-home/worker-nodes/registrar/api"
	"github.com/jaredallard-home/worker-nodes/registrar/apis/clientset/v1alpha1"
	registrar "github.com/jaredallard-home/worker-nodes/registrar/apis/types/v1alpha1"
	"github.com/jaredallard-home/worker-nodes/registrar/internal/kube"
	"github.com/jaredallard-home/worker-nodes/registrar/pkg/wghelper"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Ensure that we implemented the interface compile time
var (
	_ api.Service = &Server{}
)

// Server is the actual server implementation of the API.
type Server struct {
	k *v1alpha1.RegistrarClientset
	w *wghelper.Wireguard
}

// NewServer creates a new grpc server interface
func NewServer(ctx context.Context) (*Server, error) {
	s := &Server{}
	c, err := kube.New()
	if err != nil {
		return nil, errors.Wrap(err, "failed to create kube config")
	}

	s.k, err = v1alpha1.NewForConfig(c)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create kubernetes and registrar clientset")
	}

	s.w, err = wghelper.NewWireguard(s.k)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create wireguard controller")
	}

	_, pool, err := s.getCIDR(ctx, "default")
	if err != nil {
		return nil, errors.Wrap(err, "failed to get CIDR block")
	}

	err = s.w.StartServer(pool)
	return s, err
}

func (s *Server) getCIDR(ctx context.Context, namespace string) (*net.IPNet, *registrar.WireguardIPPool, error) {
	pools, err := s.k.RegistrarV1Alpha1Client().WireguardIPPools(namespace).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to get wireguardippools")
	}

	if len(pools.Items) == 0 {
		return nil, nil, fmt.Errorf("no active pools, retry later")
	}

	if len(pools.Items) > 1 {
		log.Warnf("found %d pools, only one is supported, using first pool", len(pools.Items))
	}

	pool := pools.Items[0]
	_, ipnet, err := net.ParseCIDR(pool.Spec.CIDR)
	if err != nil {
		return nil, nil, errors.Wrap(err, "invalid cidr")
	}

	return ipnet, &pools.Items[0], nil
}

func (s *Server) allocateIP(ctx context.Context, namespace string) (net.IP, error) {
	ipnet, pool, err := s.getCIDR(ctx, namespace)

	// TODO(jaredallard): we should not do a blind +1/2, we should recycle unused IP addresses
	// we do +2 here to account for the host most likely being set to .1
	// of course, this will break if it's not set to that. Oh well. DHCP addressing is hard.
	ip, err := cidr.Host(ipnet, pool.Status.UsedAddresses+2)

	// we increment the amount, since we're now using another
	pool.Status.UsedAddresses++

	_, err = s.k.RegistrarV1Alpha1Client().WireguardIPPools(pool.Namespace).Update(ctx, pool)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update usedAddresses on ip pool")
	}

	return ip, err
}

func (s *Server) createDevice(ctx context.Context, namespace string, r *api.RegisterRequest) error {
	ip, err := s.allocateIP(ctx, namespace)
	if err != nil {
		return errors.Wrap(err, "failed to allocate IP address")
	}

	wgip := &registrar.WireguardIP{
		ObjectMeta: metav1.ObjectMeta{
			Name: strings.ReplaceAll(ip.String(), ".", "-"),
		},
		Spec: registrar.WireguardIPSpec{
			DeviceRef: r.Id,
			IPAdress:  ip.String(),
		},
		Status: registrar.WireguardIPStatus{
			Active: true,
		},
	}

	// register in wireguard
	conf, err := s.w.Register(wgip)
	if err != nil {
		return errors.Wrap(err, "failed to add device to wireguard")
	}

	// create the device secret
	_, err = s.k.CoreV1().Secrets(namespace).Create(ctx, &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.Id,
		},
		StringData: map[string]string{
			"wireguard-key": conf.PresharedKey.String(),
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return errors.Wrap(err, "failed to create device secret")
	}

	// device doesn't exist, create it
	_, err = s.k.RegistrarV1Alpha1Client().Devices(namespace).Create(ctx, &registrar.Device{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.Id,
		},
		Spec: registrar.DeviceSpec{
			SecretRef: r.Id,
		},
		Status: registrar.DeviceStatus{
			Registered: true,
			PublicKey:  conf.PresharedKey.PublicKey().String(),
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return errors.Wrap(err, "failed to create device")
	}

	_, err = s.k.RegistrarV1Alpha1Client().WireguardIPs(namespace).Create(ctx, wgip, metav1.CreateOptions{})
	if err != nil {
		return errors.Wrap(err, "failed to create wireguard ip")
	}

	return nil
}

// Register registers a new device into the wireguard network.
// TODO(jaredallard): GC when peer is not added fully
func (s *Server) Register(ctx context.Context, r *api.RegisterRequest) (*api.RegisterResponse, error) {
	namespace := "default"

	if r.Id == "" {
		// generate a new UUID for this device
		r.Id = uuid.New().String()
	}

	log.Infof("attempting to register device '%s'", r.Id)
	resp := &api.RegisterResponse{
		Id: r.Id,
	}

	d, err := s.k.RegistrarV1Alpha1Client().Devices(namespace).Get(ctx, r.Id, metav1.GetOptions{})
	if err == nil {
		log.Infof("device '%s' already exists, returning registration information ...", r.Id)
	} else if kerrors.IsNotFound(err) {
		log.Infof("device '%s' is new, registering ...", r.Id)
		if err := s.createDevice(ctx, namespace, r); err != nil {
			return nil, errors.Wrap(err, "failed to register device")
		}
	} else if err != nil {
		// we checked all errors we handle, just return it
		return nil, err
	}

	d, err = s.k.RegistrarV1Alpha1Client().Devices(namespace).Get(ctx, r.Id, metav1.GetOptions{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to get device")
	}

	sec, err := s.k.CoreV1().Secrets(namespace).Get(ctx, d.Spec.SecretRef, metav1.GetOptions{})
	if err != nil {
		return nil, errors.Wrap(err, "failed to get device secret")
	}

	resp.Key = string(sec.Data["wireguard-key"])

	return resp, nil
}
