// Code generated by Bootstrap.
//
// Please edit this to more accurately match the server implementation.

package registrard

import (
	"context"
	"crypto/subtle"
	"fmt"
	"os"

	"github.com/google/uuid"
	"github.com/jaredallard-home/worker-nodes/registrar/api"
	"github.com/jaredallard-home/worker-nodes/registrar/apis/clientset/v1alpha1"
	registrar "github.com/jaredallard-home/worker-nodes/registrar/apis/types/v1alpha1"
	"github.com/jaredallard-home/worker-nodes/registrar/internal/kube"
	"github.com/jaredallard-home/worker-nodes/registrar/pkg/rancher"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Ensure that we implemented the interface compile time
var (
	_ api.Service = &Server{}
)

// Server is the actual server implementation of the API.
type Server struct {
	k            *v1alpha1.RegistrarClientset
	r            *rancher.Client
	authToken    []byte
	authTokenlen int32
}

// NewServer creates a new grpc server interface
func NewServer(ctx context.Context) (*Server, error) {
	s := &Server{}
	c, err := kube.New()
	if err != nil {
		return nil, errors.Wrap(err, "failed to create kube config")
	}

	s.r = rancher.NewClient(os.Getenv("RANCHER_HOST"), os.Getenv("RANCHER_TOKEN"))

	s.k, err = v1alpha1.NewForConfig(c)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create kubernetes and registrar clientset")
	}

	s.authToken = []byte(os.Getenv("REGISTRARD_TOKEN"))
	s.authTokenlen = int32(len(s.authToken))
	return s, err
}

func (s *Server) createDevice(ctx context.Context, namespace string, r *api.RegisterRequest) error {
	// device doesn't exist, create it
	_, err := s.k.RegistrarV1Alpha1Client().Devices(namespace).Create(ctx, &registrar.Device{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.Id,
		},
		Spec: registrar.DeviceSpec{},
		Status: registrar.DeviceStatus{
			Registered: true,
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return errors.Wrap(err, "failed to create device")
	}

	return nil
}

// Register registers a new device into the wireguard network.
// TODO(jaredallard): GC when peer is not added fully
func (s *Server) Register(ctx context.Context, r *api.RegisterRequest) (*api.RegisterResponse, error) {
	namespace := "registrar"
	userTokenByte := []byte(r.AuthToken)

	// we need to check if the auth token is the correct length
	if subtle.ConstantTimeEq(s.authTokenlen, int32(len(userTokenByte))) == 0 {
		return nil, fmt.Errorf("invalid auth token")
	}

	// we need to check if the token is actually valid
	if subtle.ConstantTimeCompare(s.authToken, userTokenByte) == 0 {
		return nil, fmt.Errorf("invalid auth token")
	}

	if r.Id == "" {
		// generate a new UUID for this device
		r.Id = uuid.New().String()
	}

	log.Infof("attempting to register device '%s'", r.Id)
	resp := &api.RegisterResponse{
		Id: r.Id,
	}

	_, err := s.k.RegistrarV1Alpha1Client().Devices(namespace).Get(ctx, r.Id, metav1.GetOptions{})
	if err == nil {
		log.Infof("device '%s' already exists, returning registration information ...", r.Id)
	} else if kerrors.IsNotFound(err) {
		log.Infof("device '%s' is new, registering ...", r.Id)
		if err := s.createDevice(ctx, namespace, r); err != nil {
			return nil, errors.Wrap(err, "failed to register device")
		}
	} else if err != nil {
		// we checked all errors we handle, just return it
		return nil, err
	}

	d, err := s.k.RegistrarV1Alpha1Client().Devices(namespace).Get(ctx, r.Id, metav1.GetOptions{})
	if err != nil {
		return nil, errors.New("failed to get device")
	}

	resp.Id = string(d.ObjectMeta.UID)
	resp.ClusterToken = os.Getenv("CLUSTER_TOKEN")
	resp.ClusterHost = os.Getenv("CLUSTER_HOST")

	return resp, nil
}
